"use strict";
exports.__esModule = true;
var main_1 = require("../../main");
var DataHandlerDecorators_1 = require("./decorators/DataHandlerDecorators");
var json2csv_1 = require("json2csv");
// Imports to WriteFiles
// const fs = require("fs");
/**
 * Allows to users to notify changes in the simulation to generate output data of that.
 * This is achieved with the use of the update @method, which is responsible for
 * capturing the information from the simulation. To specify what be needs to be
 * captured, the user could be make use of the followings @decorators.
 *
 * @AgentCountBoolean(name, countFalse) : allows to register "boolean" properties of
 * agents, to after, when update is called, register the state of this property
 * in all the agents which have this property, to be added to the output.
 *
 * @AgentStateIntegerCount(name, value) : allows to register "Integers" properties
 * as states of the agents, to be counted, registered and added to the output
 * after update was called.
 *
 * @AccumulateAgentValue(name) : allows to register an accumulated property
 * of agents to being added to the output each time the update was called.
 *
 * @AccumulateEnvironmentValue(name) : allows to register an accumulated property
 * of environment, which increment by each tick of clock, to after be
 * added to the output each time the update was called.
 *
 * @EnvironmentCount(name) : allows to register properties of the environment to be
 * counted and added to the output each time the update is called.
 *
 * @ExperimentCount(name) : allows to register properties of the experiment to be
 * counted and added to the output each time the update is called and normally that
 * property is updated for each repetition
 *
 */
var IDataHandler = /** @class */ (function () {
    function IDataHandler() {
        this.finalOutput = [];
    }
    /**
     * Insert the data of toAdd object in to the row object
     * @param row : object : The object to which the information is inserted
     * @param toAdd : object : The object from which the information is copied
     * @private this method is called inside the writeLine method
     */
    IDataHandler.generateRow = function (row, toAdd) {
        Reflect.ownKeys(toAdd).forEach(function (key) {
            Reflect.set(row, key, Reflect.get(toAdd, key));
        });
        return row;
    };
    /**
     * Makes a dump of the Output generated by the simulation, generating a csv file with the output formatted.
     */
    IDataHandler.dumpOutput = function (target) {
        try {
            var parser = new json2csv_1.Parser();
            var csv = parser.parse(target);
            return csv;
        }
        catch (e) {
            console.log(e);
        }
        return "";
    };
    /**
     * Allows to notify changes in the simulation. The DataHandler is notified if the simulation
     * changes by the calling of this method, what calls the writeLine method which creates and
     * extracts the data from the simulation and then are these added to the Output array.
     *
     * Normally this method is called each time the tick of the clock changes.
     */
    IDataHandler.prototype.update = function () {
        this.writeLine();
    };
    /**
     * Calls and calculates all's of the environment and agent vars what should be registered
     * by the DataHandler. Is like take a snapshot of the simulation and saves only the selected
     * data, this doing when some change is notified to the DataHandler. Usually the DataHandler
     * is notified every time when the tick of the clock changes.
     * @private this method is called by the update.
     */
    IDataHandler.prototype.writeLine = function () {
        var repetition = main_1.TimeKeeper.getRepetition();
        var tick = main_1.TimeKeeper.getTick();
        var finalRow = { repetition: repetition, tick: tick };
        // Experiments Row Data
        var experimentCountsRow = this.calculateExperimentCounts();
        // Environment Row Data
        var environmentCountsRow = this.calculateEnvironmentCounts();
        var environmentAccumRow = this.calculateEnvironmentAccum();
        // Agents Row Data
        var agentAccumRow = this.calculateAgentAccum();
        var agentBooleanCountsRow = this.calculateAgentBooleanCounts();
        var agentStatesRow = this.calculateAgentStateIntegerCounts();
        IDataHandler.generateRow(finalRow, experimentCountsRow);
        IDataHandler.generateRow(finalRow, environmentCountsRow);
        IDataHandler.generateRow(finalRow, environmentAccumRow);
        IDataHandler.generateRow(finalRow, agentAccumRow);
        IDataHandler.generateRow(finalRow, agentBooleanCountsRow);
        IDataHandler.generateRow(finalRow, agentStatesRow);
        this.finalOutput.push(finalRow);
    };
    /**
     * Calculates the environment vars to be counted in the simulation for each tick of the clock
     * @private this method is called on writeLine method.
     */
    IDataHandler.prototype.calculateEnvironmentAccum = function () {
        var _this = this;
        var envi = this.experiment.simulation.environment;
        var row = {};
        DataHandlerDecorators_1.AccumEnvironmentObjectKeys.forEach(function (item) {
            var oldValue = 0;
            if (main_1.TimeKeeper.getTick() > 0) {
                var toOut = _this.finalOutput[_this.finalOutput.length - 1];
                oldValue = Reflect.get(toOut, item.propertyKey);
            }
            var actualValue = Reflect.get(envi, item.propertyKey);
            var totalValue = oldValue + actualValue;
            Reflect.set(row, item.propertyKey, totalValue);
        });
        return row;
    };
    /**
     * Calculates the environment vars to be counted in the simulation for each tick of the clock
     * @private this method is called on writeLine method.
     */
    IDataHandler.prototype.calculateEnvironmentCounts = function () {
        var envi = this.experiment.simulation.environment;
        var row = {};
        DataHandlerDecorators_1.CountEnvironmentKeys.forEach(function (item) {
            if (item.target.constructor.name === envi.constructor.name) {
                // Registra el valor siempre y cuando sea una propiedad de la clase
                var key = item.propertyKey;
                var value = Reflect.get(envi, key);
                Reflect.set(row, item.column_name, value);
            }
        });
        return row;
    };
    /**
     * Calculates the agent states to be counted vars of the selected parameters for each agent in the simulation
     * @private this method is called on writeLine method.
     */
    IDataHandler.prototype.calculateAgentStateIntegerCounts = function () {
        var exp = this.experiment;
        var agents = exp.simulation.environment.agents;
        var row = {};
        DataHandlerDecorators_1.CountAgentStatesObjectKeysArray.forEach(function (item) {
            var countVar = 0;
            agents.forEach(function (agent) {
                if (agent.state === item.value) {
                    countVar += 1;
                }
            });
            Reflect.set(row, item.column_name, countVar);
        });
        return row;
    };
    /**
     * Registers the value from some experiment and added that to the output, normally is registered for each repetition
     * @private this method is called on writeLine method
     */
    IDataHandler.prototype.calculateExperimentCounts = function () {
        var exp = this.experiment;
        var row = {};
        DataHandlerDecorators_1.CountExperimentsKeys.forEach(function (item) {
            if (item.target.constructor.name === exp.constructor.name) {
                var key = item.propertyKey;
                var value = Reflect.get(exp, key);
                Reflect.set(row, item.column_name, value);
            }
        });
        return row;
    };
    /**
     * Calculates the agent booleans vars of the selected parameters for each agent in the simulation
     * @private this method is called on writeLine method.
     */
    IDataHandler.prototype.calculateAgentBooleanCounts = function () {
        var agents = this.experiment.simulation.environment.agents;
        var row = {};
        DataHandlerDecorators_1.CountAgentBooleanObjectKeysArray.forEach(function (item) {
            var counter = 0;
            agents.forEach(function (agent) {
                if (Reflect.has(agent, item.propertyKey) &&
                    agent.constructor.name === item.target.constructor.name) {
                    var valueFromAgent = Reflect.get(agent, item.propertyKey);
                    if (item.countFalse) {
                        // Si vamos a contar por cada agente que tenga esa property en false
                        if (!valueFromAgent) {
                            counter += 1;
                        }
                    }
                    else if (valueFromAgent) {
                        counter += 1;
                    }
                    Reflect.set(row, item.column_name, counter);
                }
            });
        });
        return row;
    };
    /**
     * Calculates the accumulation vars of the selected parameters for each agent in the simulation.
     * @private this method is called on writeLine method.
     */
    IDataHandler.prototype.calculateAgentAccum = function () {
        var agents = this.experiment.simulation.environment.agents;
        var row = {};
        DataHandlerDecorators_1.AccumAgentKeysArray.forEach(function (item) {
            var sum = 0;
            agents.forEach(function (agent) {
                if (Reflect.has(agent, item.propertyKey) &&
                    agent.constructor.name === item.target.constructor.name) {
                    sum += Reflect.get(agent, item.propertyKey);
                }
            });
            Reflect.set(row, item.propertyKey, sum);
        });
        return row;
    };
    /**
     * Exports a file with the desired data from finalOutput
     */
    IDataHandler.prototype.writeFileData = function () {
        console.log("Writing File", this.finalOutput); // todo:  move this line
        /*
        fs.writeFileSync(
          `${this.experiment.name}_output.csv`,
          IDataHandler.dumpOutput(this.finalOutput)
        );
        */
        this.finalOutput = []; // todo and this line
    };
    /**
     * Write a CSV file with the output of the Experiment
     */
    IDataHandler.prototype.writeCSVFile = function () {
        this.writeFileData();
    };
    /**
     * Return the last iteration state of the simulation
     */
    IDataHandler.prototype.getLastOutputRow = function () {
        // todo: make a method to show te output per period
        return this.finalOutput[this.finalOutput.length - 1];
    };
    IDataHandler.prototype.getState = function () {
        return {
            state: {
                selectedExperiment: main_1.TowerHandler.getSelectedExperiment(),
                actions: main_1.TowerHandler.getActionAPIState(),
                agents: main_1.TowerHandler.getAgentAPIState(),
                environments: main_1.TowerHandler.getEnvironmentAPIState(),
                experiments: main_1.TowerHandler.getExperimentAPIState(),
                agent_states: DataHandlerDecorators_1.CountAgentStatesObjectKeysArray
            }
        };
    };
    IDataHandler.prototype.writeFASOWState = function () {
        /*
        fs.writeFile(
          "FASOWState.json",
          JSON.stringify(this.getState()),
          (error: any) => {
            if (error) throw error;
          }
        );
        
         */
        console.log("Writing the fasow state in a file, please uncomment the code from up");
    };
    return IDataHandler;
}());
exports["default"] = IDataHandler;
