// @ts-ignore
import { Parser } from "json2csv";
import { TimeKeeper, TowerHandler } from "../../main";
import Agent from "../abm/Agent";
import Experiment from "../abm/Experiment";
import {
  AccumAgentKeysArray,
  CountAgentStatesObjectKeysArray,
  CountEnvironmentKeys,
  CountAgentBooleanObjectKeysArray,
  AccumEnvironmentObjectKeys,
  CountExperimentsKeys,
} from "./decorators/DataHandlerDecorators";

// Imports to WriteFiles
// const fs = require("fs");

/**
 * Allows to users to notify changes in the simulation to generate output data of that.
 * This is achieved with the use of the update @method, which is responsible for
 * capturing the information from the simulation. To specify what be needs to be
 * captured, the user could be make use of the followings @decorators.
 *
 * @AgentCountBoolean(name, countFalse) : allows to register "boolean" properties of
 * agents, to after, when update is called, register the state of this property
 * in all the agents which have this property, to be added to the output.
 *
 * @AgentStateIntegerCount(name, value) : allows to register "Integers" properties
 * as states of the agents, to be counted, registered and added to the output
 * after update was called.
 *
 * @AccumulateAgentValue(name) : allows to register an accumulated property
 * of agents to being added to the output each time the update was called.
 *
 * @AccumulateEnvironmentValue(name) : allows to register an accumulated property
 * of environment, which increment by each tick of clock, to after be
 * added to the output each time the update was called.
 *
 * @EnvironmentCount(name) : allows to register properties of the environment to be
 * counted and added to the output each time the update is called.
 *
 * @ExperimentCount(name) : allows to register properties of the experiment to be
 * counted and added to the output each time the update is called and normally that
 * property is updated for each repetition
 *
 */
export default class IDataHandler {
  experiment: Experiment | any;
  finalOutput: any[] = [];

  /**
   * Insert the data of toAdd object in to the row object
   * @param row : object : The object to which the information is inserted
   * @param toAdd : object : The object from which the information is copied
   * @private this method is called inside the writeLine method
   */
  private static generateRow(row: object, toAdd: object) {
    Reflect.ownKeys(toAdd).forEach((key) => {
      Reflect.set(row, key, Reflect.get(toAdd, key));
    });
    return row;
  }

  /**
   * Makes a dump of the Output generated by the simulation, generating a csv file with the output formatted.
   */
  private static dumpOutput(target: any[]): string {
    try {
      const parser = new Parser();
      const csv = parser.parse(target);
      return csv;
    } catch (e) {
      console.log(e);
    }
    return "";
  }

  /**
   * Allows to notify changes in the simulation. The DataHandler is notified if the simulation
   * changes by the calling of this method, what calls the writeLine method which creates and
   * extracts the data from the simulation and then are these added to the Output array.
   *
   * Normally this method is called each time the tick of the clock changes.
   */
  update(): void {
    this.writeLine();
  }

  /**
   * Calls and calculates all's of the environment and agent vars what should be registered
   * by the DataHandler. Is like take a snapshot of the simulation and saves only the selected
   * data, this doing when some change is notified to the DataHandler. Usually the DataHandler
   * is notified every time when the tick of the clock changes.
   * @private this method is called by the update.
   */
  private writeLine() {
    const repetition = TimeKeeper.getRepetition();
    const tick = TimeKeeper.getTick();
    const finalRow = { repetition, tick };

    // Experiments Row Data
    const experimentCountsRow = this.calculateExperimentCounts();

    // Environment Row Data
    const environmentCountsRow = this.calculateEnvironmentCounts();
    const environmentAccumRow = this.calculateEnvironmentAccum();

    // Agents Row Data
    const agentAccumRow = this.calculateAgentAccum();
    const agentBooleanCountsRow = this.calculateAgentBooleanCounts();
    const agentStatesRow = this.calculateAgentStateIntegerCounts();

    IDataHandler.generateRow(finalRow, experimentCountsRow);
    IDataHandler.generateRow(finalRow, environmentCountsRow);
    IDataHandler.generateRow(finalRow, environmentAccumRow);
    IDataHandler.generateRow(finalRow, agentAccumRow);
    IDataHandler.generateRow(finalRow, agentBooleanCountsRow);
    IDataHandler.generateRow(finalRow, agentStatesRow);

    this.finalOutput.push(finalRow);
  }

  /**
   * Calculates the environment vars to be counted in the simulation for each tick of the clock
   * @private this method is called on writeLine method.
   */
  private calculateEnvironmentAccum(): any {
    const envi = this.experiment.simulation.environment;
    const row = {};
    AccumEnvironmentObjectKeys.forEach((item) => {
      let oldValue = 0;
      if (TimeKeeper.getTick() > 0) {
        const toOut = this.finalOutput[this.finalOutput.length - 1];
        oldValue = Reflect.get(toOut, item.propertyKey);
      }
      const actualValue = Reflect.get(envi, item.propertyKey);
      const totalValue = oldValue + actualValue;
      Reflect.set(row, item.propertyKey, totalValue);
    });
    return row;
  }

  /**
   * Calculates the environment vars to be counted in the simulation for each tick of the clock
   * @private this method is called on writeLine method.
   */
  private calculateEnvironmentCounts(): any {
    const envi = this.experiment.simulation.environment;
    const row = {};
    CountEnvironmentKeys.forEach((item) => {
      if (item.target.constructor.name === envi.constructor.name) {
        // Registra el valor siempre y cuando sea una propiedad de la clase
        const key = item.propertyKey;
        const value = Reflect.get(envi, key);
        Reflect.set(row, item.column_name, value);
      }
    });
    return row;
  }

  /**
   * Calculates the agent states to be counted vars of the selected parameters for each agent in the simulation
   * @private this method is called on writeLine method.
   */
  private calculateAgentStateIntegerCounts(): any {
    const exp: Experiment = this.experiment;
    const { agents } = exp.simulation.environment;
    const row = {};
    CountAgentStatesObjectKeysArray.forEach((item) => {
      let countVar = 0;
      agents.forEach((agent: Agent) => {
        if (agent.state === item.value) {
          countVar += 1;
        }
      });
      Reflect.set(row, item.column_name, countVar);
    });
    return row;
  }

  /**
   * Registers the value from some experiment and added that to the output, normally is registered for each repetition
   * @private this method is called on writeLine method
   */
  private calculateExperimentCounts(): any {
    const exp: Experiment = this.experiment;
    const row = {};
    CountExperimentsKeys.forEach((item) => {
      if (item.target.constructor.name === exp.constructor.name) {
        const key = item.propertyKey;
        const value = Reflect.get(exp, key);
        Reflect.set(row, item.column_name, value);
      }
    });
    return row;
  }

  /**
   * Calculates the agent booleans vars of the selected parameters for each agent in the simulation
   * @private this method is called on writeLine method.
   */
  private calculateAgentBooleanCounts(): any {
    const { agents } = this.experiment.simulation.environment;
    const row = {};
    CountAgentBooleanObjectKeysArray.forEach((item) => {
      let counter = 0;
      agents.forEach((agent: object) => {
        if (
          Reflect.has(agent, item.propertyKey) &&
          agent.constructor.name === item.target.constructor.name
        ) {
          const valueFromAgent: boolean = Reflect.get(agent, item.propertyKey);
          if (item.countFalse) {
            // Si vamos a contar por cada agente que tenga esa property en false
            if (!valueFromAgent) {
              counter += 1;
            }
          } else if (valueFromAgent) {
            counter += 1;
          }
          Reflect.set(row, item.column_name, counter);
        }
      });
    });
    return row;
  }

  /**
   * Calculates the accumulation vars of the selected parameters for each agent in the simulation.
   * @private this method is called on writeLine method.
   */
  private calculateAgentAccum() {
    const { agents } = this.experiment.simulation.environment;
    const row = {};
    AccumAgentKeysArray.forEach((item) => {
      let sum = 0;
      agents.forEach((agent: object) => {
        if (
          Reflect.has(agent, item.propertyKey) &&
          agent.constructor.name === item.target.constructor.name
        ) {
          sum += Reflect.get(agent, item.propertyKey);
        }
      });
      Reflect.set(row, item.propertyKey, sum);
    });
    return row;
  }

  public getOutput(): any[] {
    return this.finalOutput;
  }

  public clearOutput(): any[] {
    const lastOutput: any[] = this.finalOutput;
    this.finalOutput = [];
    return lastOutput;
  }
  /**
   * Exports a file with the desired data from finalOutput
   */
  private writeFileData() {
    console.log("Writing File", this.finalOutput); // todo:  move this line
    /*
    fs.writeFileSync(
      `${this.experiment.name}_output.csv`,
      IDataHandler.dumpOutput(this.finalOutput)
    );
    */
    // this.finalOutput = []; // todo and this line
  }

  /**
   * Write a CSV file with the output of the Experiment
   */
  public writeCSVFile(): void {
    this.writeFileData();
  }

  /**
   * Return the last iteration state of the simulation
   */
  public getLastOutputRow(): any {
    // todo: make a method to show te output per period
    return this.finalOutput[this.finalOutput.length - 1];
  }

  getState(): any {
    return {
      state: {
        selectedExperiment: TowerHandler.getSelectedExperiment(),
        actions: TowerHandler.getActionAPIState(),
        agents: TowerHandler.getAgentAPIState(),
        environments: TowerHandler.getEnvironmentAPIState(),
        experiments: TowerHandler.getExperimentAPIState(),
        agent_states: CountAgentStatesObjectKeysArray,
      },
    };
  }

  writeFASOWState() {
    /*
    fs.writeFile(
      "FASOWState.json",
      JSON.stringify(this.getState()),
      (error: any) => {
        if (error) throw error;
      }
    );
    
     */
    console.log(
      "Writing the fasow state in a file, please uncomment the code from up"
    );
  }
}
